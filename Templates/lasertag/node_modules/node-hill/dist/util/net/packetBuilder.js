"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zlib_1 = require("zlib");
const smart_buffer_1 = require("smart-buffer");
const uintv = __importStar(require("./uintv"));
const game_1 = __importDefault(require("../../class/game"));
var PacketEnums;
(function (PacketEnums) {
    PacketEnums[PacketEnums["Authentication"] = 1] = "Authentication";
    PacketEnums[PacketEnums["SendBrick"] = 2] = "SendBrick";
    PacketEnums[PacketEnums["SendPlayers"] = 3] = "SendPlayers";
    PacketEnums[PacketEnums["Figure"] = 4] = "Figure";
    PacketEnums[PacketEnums["RemovePlayer"] = 5] = "RemovePlayer";
    PacketEnums[PacketEnums["Chat"] = 6] = "Chat";
    PacketEnums[PacketEnums["PlayerModification"] = 7] = "PlayerModification";
    PacketEnums[PacketEnums["Kill"] = 8] = "Kill";
    PacketEnums[PacketEnums["Brick"] = 9] = "Brick";
    PacketEnums[PacketEnums["Team"] = 10] = "Team";
    PacketEnums[PacketEnums["Tool"] = 11] = "Tool";
    PacketEnums[PacketEnums["Bot"] = 12] = "Bot";
    PacketEnums[PacketEnums["ClearMap"] = 14] = "ClearMap";
    PacketEnums[PacketEnums["DestroyBot"] = 15] = "DestroyBot";
})(PacketEnums = exports.PacketEnums || (exports.PacketEnums = {}));
class PacketBuilder {
    constructor(packetType, options) {
        if (typeof packetType === "string")
            this.packetId = PacketEnums[packetType];
        else
            this.packetId = packetType;
        this.buffer = new smart_buffer_1.SmartBuffer();
        this.options = options || {
            compression: false
        };
        this.write("uint8", this.packetId);
    }
    write(type, data) {
        switch (type) {
            case "string": {
                this.buffer.writeStringNT(data);
                break;
            }
            case "bool": {
                data = data ? 1 : 0;
                this.buffer.writeUInt8(data);
                break;
            }
            case "float": {
                this.buffer.writeFloatLE(data);
                break;
            }
            case "uint8": {
                this.buffer.writeUInt8(data);
                break;
            }
            case "uint32": {
                this.buffer.writeUInt32LE(data);
                break;
            }
        }
        return this;
    }
    transformPacket() {
        let packet = this.buffer.toBuffer();
        if (this.options.compression)
            packet = zlib_1.deflateSync(packet);
        return uintv.writeUIntv(packet);
    }
    broadcastExcept(players) {
        return __awaiter(this, void 0, void 0, function* () {
            const packet = this.transformPacket();
            let promises = [];
            for (let player of game_1.default.players) {
                if (!players.includes(player)) {
                    promises.push(new Promise((resolve) => {
                        if (!player.socket.destroyed)
                            player.socket.write(packet, null, resolve);
                    }));
                }
            }
            return Promise.all(promises);
        });
    }
    broadcast() {
        return __awaiter(this, void 0, void 0, function* () {
            const packet = this.transformPacket();
            let promises = [];
            for (const player of game_1.default.players) {
                if (!player.socket.destroyed) {
                    promises.push(new Promise((resolve) => {
                        player.socket.write(packet, null, resolve);
                    }));
                }
            }
            return Promise.all(promises);
        });
    }
    send(socket) {
        return __awaiter(this, void 0, void 0, function* () {
            const packet = this.transformPacket();
            if (socket.destroyed)
                return;
            socket.write(packet, null, () => {
                return Promise.resolve();
            });
        });
    }
}
exports.default = PacketBuilder;
