"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs = __importStar(require("fs"));
const util_1 = require("util");
const vm2_1 = require("vm2");
const game_1 = __importDefault(require("./class/game"));
const team_1 = __importDefault(require("./class/team"));
const brick_1 = __importDefault(require("./class/brick"));
const bot_1 = __importDefault(require("./class/bot"));
const color_1 = require("./util/color/color");
const packetBuilder_1 = __importDefault(require("./util/net/packetBuilder"));
const vector3_1 = __importDefault(require("./class/vector3"));
const scripts_1 = require("./scripts");
const tool_1 = __importDefault(require("./class/tool"));
const outfit_1 = __importDefault(require("./class/outfit"));
const phin = require("phin")
    .defaults({ "parse": "json", "timeout": 12000 });
const NPM_LATEST_VERSION = "https://registry.npmjs.org/node-hill/latest";
const CORE_DIRECTORY = path_1.resolve(__dirname, "./core_scripts");
function vmLoadCoreScripts(vm) {
    fs.readdirSync(CORE_DIRECTORY).forEach((file) => {
        if (!file.endsWith(".js"))
            return;
        if (!game_1.default.coreScriptsDisabled.includes(file)) {
            const coreScript = path_1.resolve(CORE_DIRECTORY, file);
            try {
                const script = fs.readFileSync(coreScript, "UTF-8");
                vm.run(new vm2_1.VMScript(script), coreScript);
                console.log(`[*] Loaded Core Script: ${file}`);
            }
            catch (err) {
                console.error(err);
            }
        }
        else {
            console.log(`[*] Disabled Core Script: ${file}`);
        }
    });
}
function vmLoadScriptsInDir(vm, dir) {
    fs.readdirSync(dir).forEach((file) => {
        if (!file.endsWith(".js"))
            return;
        const userScriptData = path_1.resolve(dir, file);
        try {
            const script = fs.readFileSync(userScriptData, "UTF-8");
            vm.run(new vm2_1.VMScript(script), userScriptData);
            console.log(`[*] Loaded User Script: ${file}`);
        }
        catch (err) {
            console.error(err);
        }
    });
}
function loadScripts() {
    const sandbox = {
        Game: game_1.default,
        world: game_1.default.world,
        Team: team_1.default,
        Brick: brick_1.default,
        Bot: bot_1.default,
        Outfit: outfit_1.default,
        util: { randomHexColor: color_1.randomHexColor },
        Tool: tool_1.default,
        PacketBuilder: packetBuilder_1.default,
        sleep: util_1.promisify(setTimeout),
        Vector3: vector3_1.default,
        debounce: (func, wait) => {
            let timeout;
            return function () {
                if (timeout)
                    return;
                timeout = setTimeout(() => {
                    timeout = null;
                }, wait);
                func.apply(this, arguments);
            };
        }
    };
    let VM_SETTINGS = {
        require: {
            external: true,
            context: "sandbox",
            builtin: ["*"],
        },
        sandbox: Object.assign(Object.assign({}, sandbox), game_1.default.sandbox)
    };
    const vm = new vm2_1.NodeVM(VM_SETTINGS);
    if (game_1.default.coreScriptsDisabled[0] !== "*")
        vmLoadCoreScripts(vm);
    else
        console.log("[*] All Core Scripts disabled.");
    if (game_1.default.userScripts)
        vmLoadScriptsInDir(vm, game_1.default.userScripts);
}
function initiateMap(map) {
    const mapName = path_1.basename(map);
    if (!mapName.endsWith(".brk")) {
        console.log("Map selected is not a .brk file. Aborting.");
        return process.exit(0);
    }
    console.clear();
    game_1.default.mapName = mapName;
    try {
        let { environment, bricks, tools, teams, spawns } = scripts_1.loadBrk(map);
        game_1.default.world.environment = environment;
        game_1.default.world.bricks = bricks;
        game_1.default.world.spawns = spawns;
        game_1.default.world.tools = tools;
        game_1.default.world.teams = teams;
    }
    catch (err) {
        console.error("Failure parsing brk: ", err && err.stack);
        return process.exit(1);
    }
    console.log(`Selected: <Port: ${game_1.default.port} | Game: ${game_1.default.gameId} | Map: ${game_1.default.mapName}>`);
}
function startServer(settings) {
    if (!settings.port || isNaN(settings.port)) {
        console.log("No port specified. Defaulted to 42480.");
        settings.port = 42480;
    }
    if (!settings.gameId || isNaN(settings.gameId)) {
        console.log("No game ID specified.");
        return process.exit(0);
    }
    if (settings.scripts)
        settings.scripts = path_1.resolve(process.cwd(), settings.scripts);
    game_1.default.port = settings.port;
    game_1.default.gameId = settings.gameId;
    game_1.default.coreScriptsDisabled = settings.coreScriptsDisabled || [];
    game_1.default.userScripts = settings.scripts;
    game_1.default.sandbox = settings.sandbox || {};
    game_1.default.local = settings.local || false;
    if (!settings.map) {
        console.warn("No map loaded. Using default baseplate.");
        game_1.default.map = false;
    }
    else {
        settings.map = path_1.resolve(process.cwd(), settings.map);
        game_1.default.map = settings.map;
        initiateMap(game_1.default.map);
    }
    game_1.default.serverSettings = settings;
    _getLatestnpmVersion().then((package_version) => {
        if (package_version !== game_1.default.version) {
            console.warn(`Your node-hill version is out of date. [Latest version: ${package_version}]. \nRun \`npm update\` to resolve.`);
        }
    }).catch(() => {
        console.warn("Failure while checking for latest node-hill version.");
    });
    require("./server");
    loadScripts();
}
exports.startServer = startServer;
function _getLatestnpmVersion() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = (yield phin({ url: NPM_LATEST_VERSION })).body;
        return data.version;
    });
}
process.on("unhandledRejection", console.error);
module.exports = { startServer };
