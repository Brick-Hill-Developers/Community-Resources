var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
let SmartBuffer = require('smart-buffer').SmartBuffer;
let zlib = require("zlib");
let uintv = require("../util/net/uintv");
let Game = require("../class/game").default;
let Player = require("../class/player").default;
let scripts = require("../scripts");
let { whiteListedKey } = require("../util/keys/whitelisted");
let checkAuth = require("../api/checkAuth");
function packetHandler(socket, packet) {
    return __awaiter(this, void 0, void 0, function* () {
        const IP = socket.IP;
        const BYTE_SIZE = uintv.readUIntv(packet);
        packet = packet.slice(BYTE_SIZE.end);
        try {
            packet = zlib.inflateSync(packet);
        }
        catch (err) {
        }
        const READER = SmartBuffer.fromBuffer(packet);
        let TYPE = undefined;
        try {
            TYPE = READER.readUInt8();
        }
        catch (err) {
            return false;
        }
        let player = socket.player;
        if (TYPE === 1 && player)
            return;
        if (TYPE !== 1 && !player)
            return;
        switch (TYPE) {
            case 1: {
                const [USER, ERR] = yield checkAuth(socket, READER);
                if (!USER || ERR) {
                    console.log(`<Client: ${IP}> Failed verification.`);
                    return scripts.kick(socket, ERR || "Server error.");
                }
                const newPlayer = new Player(socket);
                Object.defineProperties(newPlayer, {
                    userId: { value: USER.userId },
                    username: { value: USER.username },
                    admin: { value: USER.admin },
                    membershipType: { value: USER.membershipType },
                });
                console.log(`Successfully verified! (Username: ${newPlayer.username} | ID: ${newPlayer.userId} | Admin: ${newPlayer.admin})`);
                Game._newPlayer(newPlayer);
                break;
            }
            case 2: {
                let xpos, ypos, zpos, zrot;
                
                try {
                    xpos = READER.readFloatLE();
                    ypos = READER.readFloatLE();
                    zpos = READER.readFloatLE();
                    zrot = READER.readUInt32LE();
                }
                catch (err) {
                    return false;
                }
                player._updatePositionForOthers([
                    xpos, ypos, zpos, zrot
                ]);
                break;
            }
            case 3: {
                let command, args;
                try {
                    command = READER.readStringNT();
                    args = READER.readStringNT();
                }
                catch (err) {
                    return false;
                }
                if (command !== "chat")
                    return Game.emit("command", command, player, args);
                scripts.message.clientMessageAll(player, args);
                break;
            }
            case 4: {
                break;
            }
            case 5: {
                try {
                    let brickId = READER.readUInt32LE();
                    let brick = Game.world.bricks.find(brick => brick.netId === brickId);
                    if (brick && brick.clickable)
                        return brick.emit("clicked", player);
                    for (let player of Game.players) {
                        let localBricks = player.localBricks;
                        if (!localBricks.length)
                            continue;
                        let localBrick = localBricks.find(brick => brick.netId === brickId);
                        if (localBrick && localBrick.clickable) {
                            if (localBrick.socket === player.socket)
                                return localBrick.emit("clicked", player);
                        }
                    }
                }
                catch (err) {
                    return false;
                }
                break;
            }
            case 6: {
                try {
                    let click = Boolean(READER.readUInt8());
                    let key = READER.readStringNT();
                    if (click)
                        player.emit("mouseclick");
                    
                    if (key && whiteListedKey.includes(key))
                        player.emit("keypress", key);
                }
                catch (err) {
                    return false;
                }
                break;
            }
        }
    });
}
module.exports = { packetHandler };
