"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const game_1 = __importDefault(require("./game"));
const scripts = __importStar(require("../scripts"));
const packetBuilder_1 = __importStar(require("../util/net/packetBuilder"));
const createPlayerIds_1 = __importDefault(require("../net/createPlayerIds"));
const vector3_1 = __importDefault(require("./vector3"));
const tool_1 = __importDefault(require("./tool"));
var CameraType;
(function (CameraType) {
    CameraType["Fixed"] = "fixed";
    CameraType["Orbit"] = "orbit";
    CameraType["Free"] = "free";
    CameraType["First"] = "first";
})(CameraType = exports.CameraType || (exports.CameraType = {}));
var PlayerEvents;
(function (PlayerEvents) {
    PlayerEvents["InitialSpawn"] = "initialSpawn";
    PlayerEvents["Died"] = "died";
    PlayerEvents["Respawn"] = "respawn";
    PlayerEvents["AvatarLoaded"] = "avatarLoaded";
    PlayerEvents["Chatted"] = "chatted";
})(PlayerEvents || (PlayerEvents = {}));
class Player extends events_1.EventEmitter {
    constructor(socket) {
        super();
        this.destroyed = false;
        this.scale = new vector3_1.default(1, 1, 1);
        this.maxHealth = 100;
        this.muted = false;
        this.speed = 4;
        this.jumpPower = 5;
        this.score = 0;
        this.speech = "";
        this.loadAvatar = true;
        this.loadTool = true;
        Player.playerId += 1;
        this.socket = socket;
        this.netId = Player.playerId;
        this._steps = [];
        this.localBricks = [];
        this.inventory = [];
        this.blockedUsers = [];
        this.destroyed = false;
        this.position = new vector3_1.default(0, 0, 0);
        this.rotation = new vector3_1.default(0, 0, 0);
        this.scale = new vector3_1.default(1, 1, 1);
        this.cameraFOV = 60;
        this.cameraDistance = 5;
        this.cameraPosition = new vector3_1.default(0, 0, 0);
        this.cameraRotation = new vector3_1.default(0, 0, 0);
        this.cameraType = CameraType.Fixed;
        this.cameraObject = this;
        this.colors = {
            head: "#d9bc00",
            torso: "#d9bc00",
            leftArm: "#d9bc00",
            rightArm: "#d9bc00",
            leftLeg: "#d9bc00",
            rightLeg: "#d9bc00",
        };
        this.assets = {
            tool: 0,
            face: 0,
            hat1: 0,
            hat2: 0,
            hat3: 0,
        };
        this.maxHealth = 100;
        this.health = this.maxHealth;
        this.alive = false;
        this.muted = false;
        this.speed = 4;
        this.speech = "";
        this.jumpPower = 5;
        this.score = 0;
        this.toolEquipped = null;
    }
    addListener(event, listener) { return super.addListener(event, listener); }
    mouseclick(callback) {
        let clickCallback = () => {
            callback();
        };
        this.on("mouseclick", clickCallback);
        return {
            disconnect: () => this.off("mouseclick", clickCallback)
        };
    }
    keypress(callback) {
        let kpCallback = (key) => {
            callback(key);
        };
        this.on("keypress", kpCallback);
        return {
            disconnect: () => this.off("keypress", kpCallback)
        };
    }
    kick(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.kick(this.socket, message);
        });
    }
    clearMap() {
        return __awaiter(this, void 0, void 0, function* () {
            return new packetBuilder_1.default(packetBuilder_1.PacketEnums.ClearMap)
                .write("bool", true)
                .send(this.socket);
        });
    }
    _log(message, broadcast = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!game_1.default.systemMessages)
                return;
            if (broadcast)
                return scripts.message.messageAll(message);
            else
                return scripts.message.messageClient(this.socket, message);
        });
    }
    _removePlayer() {
        return __awaiter(this, void 0, void 0, function* () {
            return new packetBuilder_1.default(packetBuilder_1.PacketEnums.RemovePlayer)
                .write("uint32", this.netId)
                .broadcastExcept([this]);
        });
    }
    _left() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(`${this.username} has left the game.`);
            yield this._removePlayer();
            this._log(`\\c6[SERVER]: \\c0${this.username} has left the server!`, true);
            this.removeAllListeners();
            this._steps.forEach((loop) => {
                clearInterval(loop);
            });
            this.destroyed = true;
        });
    }
    topPrint(message, seconds) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.topPrint(this.socket, message, seconds);
        });
    }
    centerPrint(message, seconds) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.centerPrint(this.socket, message, seconds);
        });
    }
    bottomPrint(message, seconds) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.bottomPrint(this.socket, message, seconds);
        });
    }
    prompt(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.prompt(this.socket, message);
        });
    }
    message(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.message.messageClient(this.socket, message);
        });
    }
    setOutfit(outfit) {
        return __awaiter(this, void 0, void 0, function* () {
            return createPlayerIds_1.default(this, outfit.idString)
                .broadcast();
        });
    }
    setHealth(health) {
        return __awaiter(this, void 0, void 0, function* () {
            if (health <= 0 && this.alive) {
                return this.kill();
            }
            else {
                if (health > this.maxHealth)
                    this.maxHealth = health;
                this.health = health;
                return createPlayerIds_1.default(this, "e")
                    .send(this.socket);
            }
        });
    }
    setScore(score) {
        return __awaiter(this, void 0, void 0, function* () {
            this.score = score;
            return createPlayerIds_1.default(this, "X")
                .broadcast();
        });
    }
    setTeam(team) {
        return __awaiter(this, void 0, void 0, function* () {
            this.team = team;
            return createPlayerIds_1.default(this, "Y")
                .broadcast();
        });
    }
    _greet() {
        if (game_1.default.MOTD) {
            this._log(game_1.default.MOTD);
        }
        this._log(`\\c6[SERVER]: \\c0${this.username} has joined the server!`, true);
    }
    setCameraPosition(position) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cameraPosition = new vector3_1.default().fromVector(position);
            return createPlayerIds_1.default(this, "567")
                .send(this.socket);
        });
    }
    setCameraRotation(rotation) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cameraRotation = new vector3_1.default().fromVector(rotation);
            return createPlayerIds_1.default(this, "89a")
                .send(this.socket);
        });
    }
    setCameraDistance(distance) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cameraDistance = distance;
            return createPlayerIds_1.default(this, "4")
                .send(this.socket);
        });
    }
    setCameraFOV(fov) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cameraFOV = fov;
            return createPlayerIds_1.default(this, "3")
                .send(this.socket);
        });
    }
    setCameraObject(player) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cameraObject = player;
            return createPlayerIds_1.default(this, "c")
                .send(this.socket);
        });
    }
    setCameraType(type) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cameraType = type;
            return createPlayerIds_1.default(this, "b")
                .send(this.socket);
        });
    }
    getBlockedPlayers() {
        let players = [];
        for (let target of game_1.default.players) {
            if (target.blockedUsers.includes(this.userId))
                players.push(target);
        }
        return players;
    }
    addTool(tool) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inventory.includes(tool))
                throw new Error("Player already has tool equipped.");
            this.inventory.push(tool);
            return scripts.toolPacket(tool, true)
                .send(this.socket);
        });
    }
    loadBricks(bricks) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.loadBricks(bricks)
                .send(this.socket);
        });
    }
    destroyTool(tool) {
        return __awaiter(this, void 0, void 0, function* () {
            const index = this.inventory.indexOf(tool);
            if (index === -1)
                return;
            this.inventory.splice(index, 1);
            return scripts.toolPacket(tool, false)
                .send(this.socket);
        });
    }
    equipTool(tool) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inventory.includes(tool))
                yield this.addTool(tool);
            let currentTool = this.toolEquipped;
            if (currentTool === tool)
                return this.unequipTool(tool);
            if (currentTool)
                currentTool.emit("unequipped", this);
            this.toolEquipped = tool;
            tool.emit("equipped", this);
            return createPlayerIds_1.default(this, "g")
                .broadcast();
        });
    }
    unequipTool(tool) {
        return __awaiter(this, void 0, void 0, function* () {
            this.toolEquipped = null;
            tool.emit("unequipped", this);
            return createPlayerIds_1.default(this, "h")
                .broadcast();
        });
    }
    setSpeech(speech = "") {
        return __awaiter(this, void 0, void 0, function* () {
            this.speech = speech;
            return createPlayerIds_1.default(this, "f")
                .broadcastExcept(this.getBlockedPlayers());
        });
    }
    setSpeed(speedValue) {
        return __awaiter(this, void 0, void 0, function* () {
            this.speed = speedValue;
            return createPlayerIds_1.default(this, "1")
                .send(this.socket);
        });
    }
    setJumpPower(power) {
        return __awaiter(this, void 0, void 0, function* () {
            this.jumpPower = power;
            return createPlayerIds_1.default(this, "2")
                .send(this.socket);
        });
    }
    _getClients() {
        return __awaiter(this, void 0, void 0, function* () {
            if (game_1.default.playerCount <= 1)
                return;
            yield new packetBuilder_1.default(packetBuilder_1.PacketEnums.SendPlayers)
                .write("uint8", 1)
                .write("uint32", this.netId)
                .write("string", this.username)
                .write("uint32", this.userId)
                .write("uint8", this.admin)
                .write("uint8", this.membershipType)
                .broadcastExcept([this]);
            let packet = new packetBuilder_1.default(packetBuilder_1.PacketEnums.SendPlayers);
            let count = 0;
            for (let player of game_1.default.players) {
                if (player !== this) {
                    packet.write("uint32", player.netId);
                    packet.write("string", player.username);
                    packet.write("uint32", player.userId);
                    packet.write("uint8", player.admin);
                    packet.write("uint8", player.membershipType);
                    count++;
                }
            }
            if (count > 0) {
                packet.buffer.insertUInt8(count, 1);
                return packet.send(this.socket);
            }
        });
    }
    _updatePositionForOthers(pos) {
        return __awaiter(this, void 0, void 0, function* () {
            let idBuffer = "";
            if (pos[0] && this.position.x != pos[0]) {
                idBuffer += "A";
                this.position.x = pos[0];
            }
            if (pos[1] && this.position.y != pos[1]) {
                idBuffer += "B";
                this.position.y = pos[1];
            }
            if (pos[2] && this.position.z != pos[2]) {
                idBuffer += "C";
                this.position.z = pos[2];
            }
            if (pos[3] && this.rotation.z != pos[3]) {
                idBuffer += "F";
                this.rotation.z = pos[3];
            }
            if (idBuffer.length)
                return createPlayerIds_1.default(this, idBuffer)
                    .broadcastExcept([this]);
        });
    }
    newBrick(brick) {
        return __awaiter(this, void 0, void 0, function* () {
            brick.socket = this.socket;
            this.localBricks.push(brick);
            const packet = new packetBuilder_1.default(packetBuilder_1.PacketEnums.SendBrick);
            scripts.addBrickProperties(packet, brick);
            return packet.send(this.socket);
        });
    }
    setPosition(position) {
        return __awaiter(this, void 0, void 0, function* () {
            this.position = new vector3_1.default().fromVector(position);
            let packet = createPlayerIds_1.default(this, "ABCF");
            return packet.send(this.socket);
        });
    }
    setScale(scale) {
        return __awaiter(this, void 0, void 0, function* () {
            this.scale = new vector3_1.default().fromVector(scale);
            let packetBuilder = createPlayerIds_1.default(this, "GHI");
            return packetBuilder.broadcast();
        });
    }
    setAvatar(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield scripts.setAvatar(this, userId);
            let packet = createPlayerIds_1.default(this, "KLMNOPQUVW");
            return packet.broadcast();
        });
    }
    getUserInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.getUserInfo(this.userId);
        });
    }
    ownsAsset(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.playerOwnsAsset(this.userId, assetId);
        });
    }
    getRankInGroup(groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.getRankInGroup(groupId, this.userId);
        });
    }
    kill() {
        return __awaiter(this, void 0, void 0, function* () {
            this.alive = false;
            this.health = 0;
            yield new packetBuilder_1.default(packetBuilder_1.PacketEnums.Kill)
                .write("float", this.netId)
                .write("bool", true)
                .broadcast();
            yield createPlayerIds_1.default(this, "e")
                .send(this.socket);
            this.emit("died");
        });
    }
    respawn() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setPosition(this.spawnPosition || scripts.pickSpawn());
            yield new packetBuilder_1.default(packetBuilder_1.PacketEnums.Kill)
                .write("float", this.netId)
                .write("bool", false)
                .broadcast();
            this.alive = true;
            this.health = this.maxHealth;
            this.cameraType = CameraType.Orbit;
            this.cameraObject = this;
            this.cameraPosition = new vector3_1.default(0, 0, 0);
            this.cameraRotation = new vector3_1.default(0, 0, 0);
            this.cameraFOV = 60;
            this.toolEquipped = null;
            yield createPlayerIds_1.default(this, "ebc56789a3h")
                .send(this.socket);
            this.emit("respawn");
        });
    }
    setInterval(callback, delay) {
        let loop = setInterval(callback, delay);
        this._steps.push(loop);
        return loop;
    }
    setEnvironment(environment) {
        return __awaiter(this, void 0, void 0, function* () {
            return scripts.setEnvironment(environment, this.socket);
        });
    }
    _getFigures() {
        createPlayerIds_1.default(this, "ABCDEFGHIKLMNOPQUVWXYfg")
            .broadcastExcept([this]);
        for (let player of game_1.default.players) {
            if (player !== this) {
                createPlayerIds_1.default(player, "ABCDEFGHIKLMNOPQUVWXYfg")
                    .send(this.socket);
            }
        }
    }
    _getTeams() {
        for (let team of game_1.default.world.teams) {
            scripts.teamPacket(team)
                .send(this.socket);
        }
    }
    _getBots() {
        for (let bot of game_1.default.world.bots) {
            scripts.botPacket(bot)
                .send(this.socket);
        }
    }
    _joined() {
        return __awaiter(this, void 0, void 0, function* () {
            yield scripts.sendAuthInfo(this);
            yield this._getClients();
            if (this.socket.destroyed)
                return;
            console.log(`${this.username} has joined | netId: ${this.netId}`);
            this._greet();
            yield this.setEnvironment(game_1.default.world.environment);
            if (game_1.default.sendBricks) {
                let map = scripts.loadBricks(game_1.default.world.bricks);
                if (map)
                    yield map.send(this.socket);
            }
            this._getTeams();
            this._getBots();
            if (game_1.default.assignRandomTeam && game_1.default.world.teams.length)
                this.setTeam(game_1.default.world.teams[Math.floor(Math.random() * game_1.default.world.teams.length)]);
            if (game_1.default.playerSpawning)
                yield this.respawn();
            this._getFigures();
            if (this.loadAvatar) {
                yield this.setAvatar(this.userId)
                    .then(() => {
                    this.emit("avatarLoaded");
                })
                    .catch((err) => {
                    console.error(`Failure loading avatar appearance for ${this.username}: \n`, err.stack);
                });
                if (this.loadTool && this.assets.tool) {
                    const tool = new tool_1.default("Tool");
                    tool.model = this.assets.tool;
                    yield this.addTool(tool);
                }
            }
            this.emit("initialSpawn");
        });
    }
}
exports.default = Player;
Player.initialSpawn = PlayerEvents.InitialSpawn;
Player.died = PlayerEvents.Died;
Player.respawn = PlayerEvents.Respawn;
Player.avatarLoaded = PlayerEvents.AvatarLoaded;
Player.chatted = PlayerEvents.Chatted;
Player.playerId = 0;
