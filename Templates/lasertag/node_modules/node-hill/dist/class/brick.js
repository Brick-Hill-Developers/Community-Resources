"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const game_1 = __importDefault(require("./game"));
const createBrickIds_1 = __importDefault(require("../net/createBrickIds"));
const vector3_1 = __importDefault(require("./vector3"));
const TOUCH_EVENTS = ["touching", "touchingEnded"];
class Brick extends events_1.EventEmitter {
    constructor(position, scale, color = "#C0C0C0") {
        super();
        this.lightEnabled = false;
        this.lightColor = "#000000";
        this.lightRange = 5;
        this.visibility = 0;
        this.collision = true;
        this.clickable = false;
        this.clickDistance = 50;
        Brick.brickId += 1;
        this.destroyed = false;
        this._steps = [];
        this.position = position;
        this.scale = scale;
        this.color = color;
        this.lightColor = "#000000";
        this.lightRange = 5;
        this.visibility = 1;
        this.netId = Brick.brickId;
        this.collision = true;
        this.lightEnabled = false;
        this._playersTouching = new Set();
        this.on("newListener", (event) => {
            if (this._hitMonitor)
                return;
            if (!TOUCH_EVENTS.includes(event))
                return;
            this._detectTouching();
        });
        this.on("removeListener", (event) => {
            if (event !== "touching")
                return;
            if (this.listenerCount("touching"))
                return;
            clearInterval(this._hitMonitor);
        });
    }
    setPosition(position) {
        return __awaiter(this, void 0, void 0, function* () {
            this.position = new vector3_1.default().fromVector(position);
            return createBrickIds_1.default(this, "pos");
        });
    }
    setScale(scale) {
        return __awaiter(this, void 0, void 0, function* () {
            this.scale = new vector3_1.default().fromVector(scale);
            return createBrickIds_1.default(this, "scale");
        });
    }
    setRotation(rot) {
        return __awaiter(this, void 0, void 0, function* () {
            //if (rot % 90 !== 0) {
            //    throw new Error("Rotation must be divisible by 90.");
            //}
            this.rotation = rot;
            return createBrickIds_1.default(this, "rot");
        });
    }
    setModel(model) {
        return __awaiter(this, void 0, void 0, function* () {
            this.model = model;
            return createBrickIds_1.default(this, "model");
        });
    }
    setColor(color) {
        return __awaiter(this, void 0, void 0, function* () {
            this.color = color;
            return createBrickIds_1.default(this, "col");
        });
    }
    setLightColor(color) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.lightEnabled)
                throw new Error("brick.lightEnabled must be enabled first!");
            this.lightColor = color;
            return createBrickIds_1.default(this, "lightcol");
        });
    }
    setLightRange(range) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.lightEnabled)
                throw new Error("brick.lightEnabled must be enabled first!");
            this.lightRange = range;
            return createBrickIds_1.default(this, "lightrange");
        });
    }
    setVisibility(visibility) {
        return __awaiter(this, void 0, void 0, function* () {
            this.visibility = visibility;
            return createBrickIds_1.default(this, "alpha");
        });
    }
    setCollision(collision) {
        return __awaiter(this, void 0, void 0, function* () {
            this.collision = collision;
            return createBrickIds_1.default(this, "collide");
        });
    }
    setClickable(clickable, clickDistance = 50) {
        return __awaiter(this, void 0, void 0, function* () {
            this.clickable = clickable;
            this.clickDistance = clickDistance;
            return createBrickIds_1.default(this, "clickable");
        });
    }
    setInterval(callback, delay) {
        let loop = setInterval(callback, delay);
        this._steps.push(loop);
        return loop;
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.destroyed)
                throw new Error("Brick has already been destroyed.");
            clearInterval(this._hitMonitor);
            this.removeAllListeners();
            this._steps.forEach((loop) => {
                clearInterval(loop);
            });
            if (!this.socket) {
                const bricks = game_1.default.world.bricks;
                const index = bricks.indexOf(this);
                if (index !== -1)
                    bricks.splice(index, 1);
            }
            else {
                const locals = this.socket.player.localBricks;
                const index = locals.indexOf(this);
                if (index !== -1)
                    locals.splice(index, 1);
            }
            this.destroyed = true;
            return createBrickIds_1.default(this, "destroy");
        });
    }
    _hitDetection() {
        let scale = [];
        let origin = [];
        scale[0] = this.scale.x / 2;
        scale[1] = this.scale.y / 2;
        scale[2] = this.scale.z / 2;
        origin[0] = this.position.x + scale[0];
        origin[1] = this.position.y + scale[1];
        origin[2] = this.position.z + scale[2];
        let players = [];
        if (this.socket)
            players.push(this.socket.player);
        else
            players = game_1.default.players;
        for (let p of players) {
            let size = [];
            size[0] = p.scale.x;
            size[1] = p.scale.y;
            size[2] = 5 * p.scale.z / 2;
            let center = [];
            center[0] = p.position.x;
            center[1] = p.position.y;
            center[2] = p.position.z + size[2];
            let touched = true;
            for (let i = 0; i < 3; i++) {
                let dist = Math.abs(origin[i] - center[i]);
                let close = size[i] + scale[i];
                if (dist >= close + 0.4) {
                    touched = false;
                }
            }
            if (touched && p.alive) {
                this._playersTouching.add(p);
                this.emit("touching", p);
            }
            if (this._playersTouching.has(p) && (!touched || !p.alive)) {
                this._playersTouching.delete(p);
                this.emit("touchingEnded", p);
            }
        }
    }
    clicked(callback) {
        if (!this.clickable)
            this.setClickable(true, this.clickDistance);
        let clickEvent = (p) => {
            let secure = false;
            if ((Math.pow(this.position.x - p.position.x, 2) +
                Math.pow(this.position.y - p.position.y, 2) +
                Math.pow(this.position.z - p.position.z, 2)) <= this.clickDistance)
                secure = true;
            callback(p, secure);
        };
        this.on("clicked", clickEvent);
        return {
            disconnect: () => {
                this.setClickable(false);
                this.off("clicked", clickEvent);
                return null;
            }
        };
    }
    touchingEnded(callback) {
        let touchEvent = (p) => {
            callback(p);
        };
        this.on("touchingEnded", touchEvent);
        return {
            disconnect: () => this.off("touchingEnded", touchEvent)
        };
    }
    touching(callback) {
        let touchEvent = (p) => {
            callback(p);
        };
        this.on("touching", touchEvent);
        return {
            disconnect: () => this.off("touching", touchEvent)
        };
    }
    _detectTouching() {
        this._hitMonitor = setInterval(() => {
            for (let p of this._playersTouching) {
                if (p.destroyed) {
                    this._playersTouching.delete(p);
                }
            }
            if (!game_1.default.playerCount)
                return;
            this._hitDetection();
        }, 100);
    }
}
exports.default = Brick;
Brick.brickId = 0;
